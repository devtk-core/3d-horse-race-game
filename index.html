<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D競馬ゲーム</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #87CEEB; touch-action: manipulation; }
        
        #ui-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 100; background: rgba(255, 255, 255, 0.95); padding: 20px;
            border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            width: 80%; max-width: 320px; text-align: center;
        }
        h3 { margin: 0 0 15px 0; font-size: 20px; color: #333; }
        p { font-size: 14px; margin-bottom: 15px; color: #666; }
        button {
            padding: 15px; font-size: 16px; cursor: pointer; width: 100%;
            margin-bottom: 10px; border: none; border-radius: 8px; font-weight: bold;
            transition: transform 0.1s; touch-action: manipulation; 
        }
        button:active { transform: scale(0.95); }
        #runBtn { background-color: #ff5722; color: white; }
        
        #cameraBtn { 
            position: absolute; top: 10px; left: 10px; width: auto;
            background-color: #2196F3; color: white; 
            z-index: 101; padding: 10px 15px; font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: none; 
        }
        
        #mashBtn {
            position: absolute; bottom: 20px; left: 5%; width: 90%;
            height: 80px; font-size: 24px; background-color: #FFC107; color: #333;
            border-bottom: 6px solid #FFA000; border-radius: 12px; z-index: 101;
            display: none; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        #mashBtn:active { border-bottom: 2px solid #FFA000; transform: translateY(4px); }
        
        input[type="file"] { margin-bottom: 20px; width: 100%; font-size: 14px; }
        
        #hud {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0,0,0,0.6); color: white; padding: 10px 15px;
            border-radius: 8px; font-family: monospace; font-size: 16px; display: none; z-index: 90;
        }
        #result {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 60px; font-weight: bold; color: white; text-shadow: 2px 2px 0 #000;
            display: none; z-index: 200; white-space: nowrap;
        }
    </style>
</head>
<body>
<div id="ui-container">
    <h3>3D競馬ゲーム<br><small>（斜め追尾修正版）</small></h3>
    <input type="file" id="imageLoader" accept="image/*">
    <div id="controls">
        <p>画像を読み込んでね！</p>
        <button id="runBtn" disabled>レース開始</button>
    </div>
</div>

<button id="cameraBtn">?? 視点：全体</button>
<button id="mashBtn">連打</button>
<div id="hud">YOU: <span id="lap-p">0</span>/3<br>CPU: <span id="lap-c">0</span>/3</div>
<div id="result">WIN!</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // --- 1. シーン設定 ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); 
    scene.fog = new THREE.Fog(0x87CEEB, 100, 300);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 100, 50);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.left = -100; dirLight.shadow.camera.right = 100;
    dirLight.shadow.camera.top = 100; dirLight.shadow.camera.bottom = -100;
    scene.add(dirLight);

    const planeGeometry = new THREE.PlaneGeometry(3000, 3000);
    const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -0.2;
    plane.receiveShadow = true;
    scene.add(plane);

    // --- 2. コース作成 ---
    const trackRadiusX = 35; 
    const trackRadiusZ = 20; 
    const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3( trackRadiusX, 0,  0), 
        new THREE.Vector3( 0, 0, -trackRadiusZ),
        new THREE.Vector3(-trackRadiusX, 0,  0), 
        new THREE.Vector3( 0, 0,  trackRadiusZ)
    ]);
    curve.closed = true;

    const tubeRadius = 6; 
    const tubeGeometry = new THREE.TubeGeometry(curve, 80, tubeRadius, 8, true);
    const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    const track = new THREE.Mesh(tubeGeometry, trackMaterial);
    track.scale.set(1, 0.02, 1); 
    track.position.y = 0;
    track.receiveShadow = true;
    scene.add(track);

    // --- 3. ゲーム変数 ---
    let playerGroup, enemyGroup; 
    let isRunning = false; isFinished = false; 
    let cameraMode = 0; // 0:全体, 1:追尾(斜め), 2:主観
    let time = 0;

    let playerProgress = 0; let playerLap = 0; let playerSpeed = 0;
    let cpuProgress = 0; let cpuLap = 0; let cpuSpeed = 0.0015;

    const ui = {
        container: document.getElementById('ui-container'), loader: document.getElementById('imageLoader'),
        runBtn: document.getElementById('runBtn'), cameraBtn: document.getElementById('cameraBtn'),
        mashBtn: document.getElementById('mashBtn'), hud: document.getElementById('hud'),
        lapP: document.getElementById('lap-p'), lapC: document.getElementById('lap-c'), result: document.getElementById('result')
    };

    // --- 4. 画像読み込み ---
    ui.loader.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(event) {
            const imgObj = new Image(); imgObj.src = event.target.result;
            imgObj.onload = function() { setupHorses(imgObj); ui.runBtn.disabled = false; ui.runBtn.innerText = "レース開始！"; };
        };
        reader.readAsDataURL(file);
    });

    function createHorseMesh(texture, color = 0xffffff) {
        const aspect = texture.image.width / texture.image.height;
        const baseSize = 5;
        const geometry = new THREE.PlaneGeometry(baseSize * aspect, baseSize);
        const material = new THREE.MeshStandardMaterial({
            map: texture, transparent: true, alphaTest: 0.5, side: THREE.DoubleSide, color: color
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true; return mesh;
    }

    function setupHorses(imgObj) {
        if (playerGroup) scene.remove(playerGroup); if (enemyGroup) scene.remove(enemyGroup);
        const texture = new THREE.Texture(imgObj); texture.needsUpdate = true;
        const baseHeight = 0.2;
        
        playerGroup = new THREE.Group();
        const pMesh = createHorseMesh(texture, 0xffffff);
        pMesh.rotation.y = Math.PI / 2; pMesh.position.y = 2.5; 
        playerGroup.add(pMesh); playerGroup.position.y = baseHeight; scene.add(playerGroup);
        
        enemyGroup = new THREE.Group();
        const cMesh = createHorseMesh(texture, 0xffaaaa);
        cMesh.rotation.y = Math.PI / 2; cMesh.position.y = 2.5;
        enemyGroup.add(cMesh); enemyGroup.position.y = baseHeight; scene.add(enemyGroup);
        
        updateHorseTransform(playerGroup, 0, 2); updateHorseTransform(enemyGroup, 0, -2);
        ui.cameraBtn.style.display = "block";
    }

    // --- 5. 操作 ---
    ui.runBtn.addEventListener('click', () => {
        isRunning = true; isFinished = false; ui.container.style.display = 'none';
        ui.mashBtn.style.display = 'block'; ui.hud.style.display = 'block';
    });

    ui.cameraBtn.addEventListener('click', () => { 
        cameraMode = (cameraMode + 1) % 3; 
        if (cameraMode === 0) ui.cameraBtn.innerText = "?? 視点：全体";
        else if (cameraMode === 1) ui.cameraBtn.innerText = "?? 視点：斜め追尾";
        else if (cameraMode === 2) ui.cameraBtn.innerText = "?? 視点：主観";
    });

    function boost() {
        if (!isRunning || isFinished) return;
        playerSpeed += 0.0008; if (playerSpeed > 0.015) playerSpeed = 0.015;
    }
    document.addEventListener('keydown', (e) => { if (e.code === 'Space') boost(); });
    ui.mashBtn.addEventListener('mousedown', (e) => { e.preventDefault(); boost(); });
    ui.mashBtn.addEventListener('touchstart', (e) => { e.preventDefault(); boost(); });

    // --- 6. アニメーション ---
    function animate() {
        requestAnimationFrame(animate);
        if (playerGroup && isRunning && !isFinished) {
            playerProgress += playerSpeed; playerSpeed *= 0.96;
            let currentCpuSpeed = cpuSpeed; if (playerProgress > cpuProgress) currentCpuSpeed *= 1.15; 
            cpuProgress += currentCpuSpeed;
            if (Math.floor(playerProgress) > playerLap) { playerLap = Math.floor(playerProgress); ui.lapP.innerText = playerLap; }
            if (Math.floor(cpuProgress) > cpuLap) { cpuLap = Math.floor(cpuProgress); ui.lapC.innerText = cpuLap; }
            if (playerLap >= 3 || cpuLap >= 3) finishRace(playerLap >= 3);
            updateHorseTransform(playerGroup, playerProgress % 1, 2); updateHorseTransform(enemyGroup, cpuProgress % 1, -2);
            time += 0.3;
            playerGroup.position.y = 0.2 + Math.abs(Math.sin(time)) * (0.2 + playerSpeed * 40);
            enemyGroup.position.y = 0.2 + Math.abs(Math.sin(time * 0.9)) * 0.3;
        }
        
        // ★カメラ制御（修正）
        if (playerGroup) {
            if (cameraMode === 0) {
                // 全体
                camera.position.set(0, 120, 150);
                camera.lookAt(0, 0, 0);
            } 
            else if (cameraMode === 1) {
                // ★修正：斜め後ろからの追尾視点
                const pPos = playerGroup.position.clone();
                const tangent = curve.getTangent(playerProgress % 1).normalize();
                
                // 横方向（右）のベクトルを計算
                const up = new THREE.Vector3(0, 1, 0);
                const sideVec = new THREE.Vector3().crossVectors(tangent, up).normalize();
                
                // カメラ位置計算：
                // 1. 後ろに20下がる (-tangent * 20)
                // 2. 上に10上がる (+Y * 10)
                // 3. 右に15ずれる (+sideVec * 15) ← これで斜めになる！
                const offset = new THREE.Vector3().copy(tangent).multiplyScalar(-20)
                                                .add(new THREE.Vector3(0, 10, 0))
                                                .add(sideVec.multiplyScalar(15)); 

                const camPos = pPos.clone().add(offset);
                camera.position.copy(camPos);
                camera.lookAt(pPos);
            } 
            else if (cameraMode === 2) {
                // 主観
                const pPos = playerGroup.position.clone();
                const tangent = curve.getTangent(playerProgress % 1).normalize();
                camera.position.copy(pPos).add(new THREE.Vector3(0, 4, 0));
                const lookTarget = pPos.clone().add(tangent.clone().multiplyScalar(10));
                camera.lookAt(lookTarget);
            }
        }
        renderer.render(scene, camera);
    }
    
    function updateHorseTransform(group, prog, offsetSide) {
        const point = curve.getPoint(prog); const tangent = curve.getTangent(prog).normalize();
        const sideVector = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0, 1, 0)).normalize();
        group.position.x = point.x + (sideVector.x * offsetSide); group.position.z = point.z + (sideVector.z * offsetSide);
        group.lookAt(group.position.clone().add(tangent));
    }
    function finishRace(isPlayerWin) {
        isFinished = true; ui.result.style.display = 'block'; ui.mashBtn.style.display = 'none';
        ui.result.innerText = isPlayerWin ? "WIN!! ??" : "LOSE... ??";
        ui.result.style.color = isPlayerWin ? "gold" : "gray";
        setTimeout(() => { alert("リロードしてもう一度遊んでね！"); }, 1000);
    }
    animate();
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>

</html>
